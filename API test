Question 15: Difference between REST APIs and SOAP APIs
Answer 15: REST is way simpler and more lightweight. we are basically using standard HTTP methods to talk to an API—GET, POST, that kind of thing. SOAP is more formal and structured, like it's got all these rules and it uses XML. REST is faster and easier to work with, honestly. Most modern APIs are REST now. SOAP's older and more enterprise-y. For testing purposes, REST is definitely easier to work with because you can just use a browser or a simple tool. SOAP requires more setup and is kind of a pain.
Question 16: HTTP methods in REST APIs
Answer 16:These are the verbs that tell the API what we want to do. GET is read-only—you're asking for data. POST is when we are creating something new. PUT is when you're updating something that already exists. DELETE is when we want to remove something. It matters because the API expects you to use the right method for the right action. If we POST when we should GET, things break. When I'm testing, I make sure devs are using these correctly and that the API responds properly to each one.
Question 17: API testing tools
Answer 17: I use Postman all the time. It's super straightforward—you set up the requests, plug in data, hit send, and see what comes back. It can organize collections of tests, automate them, check responses. I've also looked at Swagger for documentation and understanding what an API should do. JMeter I've used when we need to do load testing to see how an API handles tons of requests at once. Postman's my go-to though because it's intuitive and you don't need to be a programmer to use it effectively.
Question 18: Experience with manual testing
Answer 18:Yeah, I do a lot of manual testing. That's honestly where I spend most of my time. I'll open the app, click around, try different things, see if it works the way it should. You catch a lot of stuff this way that automation misses—weird UI issues, things that feel clunky, flows that don't make sense. I automate where it makes sense, like repetitive stuff, but there's no substitute for actually using the thing like a real user would. Manual testing is where I find the interesting bugs.
Question 19: Testing SDK integration
Answer 19: When we integrate an SDK into an app, I need to make sure it actually works in the real application. So I'll install it, run through the flows that use that SDK, and check if everything behaves right. I test both happy paths and error cases—what happens when the SDK fails or the network is down? I also watch for any side effects, like does it drain battery or break other features? I'll coordinate with the dev to make sure they integrated it correctly and that I'm testing it the right way.
Question 20: Getting a 401 Unauthorized response
Answer 20: Okay, so 401 means the system doesn't recognize who I am. First thing I check is my credentials—am I passing the right auth token or API key? Maybe it expired or I'm using the wrong one. I'll verify with the dev team that I have the right token for the environment I'm testing in. Sometimes it's a permissions thing—I have valid credentials but I'm not allowed to access that endpoint. I'll also check if the header format is right, because that matters for auth. Usually it's just a bad token or expired credentials though.
Question 21: HTTP status codes in API responses
Answer 21: Status codes tell you what happened with your request. 200 means success—everything's good. 400 means you messed up your request somehow, like you sent bad data. 401 is unauthorized—you need to log in or provide valid credentials. 403 is forbidden—you're authenticated but don't have permission. 404 means the thing you're looking for doesn't exist. 500 means the server messed up. There are a bunch more, but those are the main ones I see all the time. When I'm testing, I make sure the API returns the right code for different situations because that's how applications know what went wrong.
Question 22: Experience in mobile/web app testing
Answer 22: I've done both, honestly. With web apps, I test on different browsers—Chrome, Firefox, Safari, Edge—because things render differently and we never know what users are using. I check responsiveness, make sure it works on different screen sizes, test the flows. Mobile's a bit different because we are dealing with touch interactions, device-specific stuff, network variations. I've tested on both Android and iOS, and the experience is pretty different. Mobile's trickier because we've got to think about things like what happens when you get a call or a notification while using the app, or if the network drops. I use actual devices when I can because simulators don't catch everything. Web testing is usually faster to iterate on, but mobile testing is where you find the really annoying bugs that impact users the most.
Question 23: Programming languages I've worked with
Answer 23: I'm not a programmer, but I've picked up some basics over time just from working with devs. I can read and understand JavaScript, which helps when I'm testing web apps and need to understand how things work. I've messed around with Python a bit, mostly for writing simple automation scripts. I know SQL well enough to query test databases and verify data, which is super helpful. I'm not fluent in any language, but understanding the basics really helps me communicate with developers and write better test automation. It makes me better at my job because I can understand what devs are talking about and why bugs happen the way they do.
